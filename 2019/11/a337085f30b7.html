<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="http与浏览器的缓存机制"><meta name="keywords" content="网络原理"><meta name="author" content="EsunR"><meta name="copyright" content="EsunR"><title>http与浏览器的缓存机制 | EsunR-Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?31bd12722efcf47cb7d0d576bf150215";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-3RG97DCL3N"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-3RG97DCL3N');</script><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80"><span class="toc-text">缓存基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Cache-control"><span class="toc-text">1. Cache-control</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%A6%81%E6%AD%A2%E7%BC%93%E5%AD%98"><span class="toc-text">1.1 禁止缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%BC%BA%E5%88%B6%E7%A1%AE%E8%AE%A4%E7%BC%93%E5%AD%98"><span class="toc-text">1.2 强制确认缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%A7%81%E6%9C%89%E7%BC%93%E5%AD%98%E5%92%8C%E5%85%AC%E5%85%B1%E7%BC%93%E5%AD%98"><span class="toc-text">1.3 私有缓存和公共缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6"><span class="toc-text">1.4 缓存过期机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%BC%93%E5%AD%98%E9%AA%8C%E8%AF%81%E7%A1%AE%E8%AE%A4"><span class="toc-text">1.5 缓存验证确认</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-ETag"><span class="toc-text">2. ETag</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%A3%80%E6%B5%8B%E8%B5%84%E6%BA%90%E6%98%AF%E5%90%A6%E5%8F%98%E6%9B%B4"><span class="toc-text">2.1 检测资源是否变更</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%98%B2%E6%AD%A2-%E2%80%9C%E7%A9%BA%E4%B8%AD%E7%A2%B0%E6%92%9E%E2%80%9D"><span class="toc-text">2.2 防止 “空中碰撞”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Last-Modify"><span class="toc-text">3. Last-Modify</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://esunr-webapp.cdn.bcebos.com/blog/avatar.jpeg?x-bce-process=image/resize,m_lfit,w_200/format,f_auto" alt="avatar"></div><div class="author-info__name text-center">EsunR</div><div class="author-info__description text-center">EsunR-Blog是由EsunR维护的博客平台，分享在前端开发、Git、Vue.js、Webpack、OAuth、Linux等各个领域的知识和经验。浏览这里的深入文章，了解不同主题的见解，并及时了解行业的最新趋势和技术。</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/EsunR">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">170</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">151</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">25</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://esunr-webapp.cdn.bcebos.com/blog/background.png?x-bce-process=image/quality,q_80/format,f_auto)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">EsunR-Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><span class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></span></span></div><div id="post-info"><div id="post-title">http与浏览器的缓存机制</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-26</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2019/11/a337085f30b7.html#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2019/11/a337085f30b7.html"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.7k</span><span class="post-meta__separator">|</span><span>Reading time: 5 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="缓存基础"><a href="#缓存基础" class="headerlink" title="缓存基础"></a>缓存基础</h1><p>首先我们要知道缓存的目的是什么？</p>
<p>使用缓存可以有效的减少服务器的请求次数，这一特性主要用于缓存静态资源，对于长期不会改变的服务器静态资源，启用缓存则无需从服务器二次下载。</p>
<p>缓存分为两种类型，分为 <strong>强制缓存</strong> 与 <strong>协商缓存</strong>：</p>
<p>对于强制缓存，浏览器会根据上次请求获取的 <code>Cache-Controller</code> 或 <code>Expires(http 1.0 规范)</code> 来判断截止当前请求发起时，本地的缓存资源是否过期，如果本地缓存的资源未过期，就会启用本地的缓存而不向服务器建立连接，此时虽然没有建立服务器端的连接，但仍会收到 200 的状态码，但是会被标记为 <code>from cache</code>。</p>
<p>然而协商缓存是通过上次请求的 <code>Etag</code> 或 <code>Last-Modified</code> 与服务器对比请求资源的信息来判断缓存资源是否过期，如果过期就重新获取资源，没有过期就启用本地的缓存资源而不再向服务器下载该资源，此时会收到 304 的状态码，标记为 <code>not modified</code>。协商缓存要比强缓存流程要多一些，具体过程入下：</p>
<p><img src="https://i.loli.net/2021/07/20/e1cLN3xQdi6aDh4.png" alt=""></p>
<p>如果不使用缓存，那么浏览器每发起一个请求就会从服务器重新获取一遍资源，对于大多数服务器来说，是不会启用这一方式的，只有用户使用 <code>ctrl + F5</code> 刷新页面时才会重新请求资源。</p>
<h1 id="1-Cache-control"><a href="#1-Cache-control" class="headerlink" title="1. Cache-control"></a>1. Cache-control</h1><p>在 Http/1.1 Header 的 <code>Cache-control</code> 字段可以存放缓存相关的信息，以 Express 框架为例，我们可以使用 <code>req.set</code> 来设置 Http Header，从而自定义请求缓存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/resource&quot;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">set</span>(&#123; <span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;no-store&quot;</span> &#125;);</span><br><span class="line">  res.<span class="title function_">send</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;huahua&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通常可以进行如下几项设置：</p>
<h2 id="1-1-禁止缓存"><a href="#1-1-禁止缓存" class="headerlink" title="1.1 禁止缓存"></a>1.1 禁止缓存</h2><p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>

<p>启用 no-store 后每次请求状态码都是 200 ，意味着每次请求都是从服务器重新获取的。</p>
<p><img src="https://i.loli.net/2019/11/27/t8GiJYRX9anbdrC.png" alt=""></p>
<h2 id="1-2-强制确认缓存"><a href="#1-2-强制确认缓存" class="headerlink" title="1.2 强制确认缓存"></a>1.2 强制确认缓存</h2><p>如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期，服务器会向客户端返回一个 304 状态码表示资源未被转移，客户端可以使用本地缓存。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/11/27/jicZeKFHkGhCYaJ.png" alt="20191127003501.png"></p>
<h2 id="1-3-私有缓存和公共缓存"><a href="#1-3-私有缓存和公共缓存" class="headerlink" title="1.3 私有缓存和公共缓存"></a>1.3 私有缓存和公共缓存</h2><p>“public” 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了”public”，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。</p>
<p>而 “private” 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>

<h2 id="1-4-缓存过期机制"><a href="#1-4-缓存过期机制" class="headerlink" title="1.4 缓存过期机制"></a>1.4 缓存过期机制</h2><p>过期机制中，最重要的指令是 “<code>max-age=&lt;seconds&gt;</code>“，表示资源能够被缓存（保持新鲜）的最大时间。相对<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires">Expires</a>而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>

<p>启用 <code>max-age</code> 缓存时，浏览器会一直读取本地资源而不向服务器发起请求：</p>
<p><img src="https://i.loli.net/2019/11/27/VjtNYor2aZ7GwDn.png" alt=""></p>
<h2 id="1-5-缓存验证确认"><a href="#1-5-缓存验证确认" class="headerlink" title="1.5 缓存验证确认"></a>1.5 缓存验证确认</h2><p>当使用了 “<code>must-revalidate</code>“ 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。详情看下文关于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ#Cache_validation">缓存校验</a>的内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure>

<h1 id="2-ETag"><a href="#2-ETag" class="headerlink" title="2. ETag"></a>2. ETag</h1><p>ETag 是在响应头中存放的一个字段，用于校验服务器资源是否过期，从而判断是否启用缓存，对于访问服务器的静态资源来说，ETag 可以表示为静态文件的 Hash。</p>
<p>如果给定URL中的资源更改，则一定要生成新的 Etag 值。 因此 Etag 类似于指纹，也可能被某些服务器用于跟踪。 比较 Etag 能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。</p>
<p>ETag 通常用于实现两种功能：</p>
<ol>
<li>检测资源是否变更，如未变更，则采用缓存资源</li>
<li>防止资源请求过程中发生“空中碰撞”</li>
</ol>
<h2 id="2-1-检测资源是否变更"><a href="#2-1-检测资源是否变更" class="headerlink" title="2.1 检测资源是否变更"></a>2.1 检测资源是否变更</h2><p>通常用户首次发起请求时，服务器端返回的响应报文的响应头部中会包含 ETag 的信息，如：</p>
<p><img src="https://i.loli.net/2021/06/21/ScHltx59j6kAXyn.png" alt=""></p>
<p>这一信息将被客户端所记录，并且在后续的请求中会在请求报文的头部添加一个 <code>if-none-match</code> 的字段，该请求发送到服务器端时，会检测与服务器端 ETag 是否匹配，如果匹配到，说明资源未发生变更，此时会返回 304 状态码，客户端则会读取缓存资源，如：</p>
<p><img src="https://i.loli.net/2021/06/21/4YDweO9yNboTFQ3.png" alt=""></p>
<h2 id="2-2-防止-“空中碰撞”"><a href="#2-2-防止-“空中碰撞”" class="headerlink" title="2.2 防止 “空中碰撞”"></a>2.2 防止 “空中碰撞”</h2><p>在<code>ETag</code>和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match"><code>If-Match</code></a> 头部的帮助下，您可以检测到”空中碰撞”的编辑冲突。</p>
<p>例如，当编辑MDN时，当前的wiki内容被散列，并在响应中放入<code>Etag</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4</span><br></pre></td></tr></table></figure>

<p>将更改保存到Wiki页面（发布数据）时，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a>请求将包含有ETag值的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match"><code>If-Match</code></a>头来检查是否为最新版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>

<p>如果哈希值不匹配，则意味着文档已经被编辑，抛出<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/412"><code>412</code></a>前提条件失败错误。</p>
<h1 id="3-Last-Modify"><a href="#3-Last-Modify" class="headerlink" title="3. Last-Modify"></a>3. Last-Modify</h1><p>The <strong><code>Last-Modified</code></strong>  是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag"><code>ETag</code></a> 要低，所以这是一个备用机制。包含有  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since"><code>If-Modified-Since</code></a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since"><code>If-Unmodified-Since</code></a> 首部的条件请求会使用这个字段。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/">网络原理</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-62c7f2684e36ba34" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/11/51e765ec4f55.html"><i class="fa fa-chevron-left">  </i><span>重拾JSONP，手动封装JSONP的多种写法</span></a></div><div class="next-post pull-right"><a href="/2019/11/a3089ef6c32b.html"><span>Surface Pro 6 日常使用问题记录</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://blog.esunr.site/2019/11/a337085f30b7.html';
  this.page.identifier = '2019/11/a337085f30b7.html';
  this.page.title = 'http与浏览器的缓存机制';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'esunr-blog' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://esunr-blog.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://esunr-webapp.cdn.bcebos.com/blog/background.png?x-bce-process=image/quality,q_80/format,f_auto)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2025 By EsunR</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>