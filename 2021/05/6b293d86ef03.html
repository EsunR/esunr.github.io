<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="图文并茂,React组件更新与渲染及Diff算法解析"><meta name="keywords" content="React,源码解析"><meta name="author" content="EsunR"><meta name="copyright" content="EsunR"><title>图文并茂,React组件更新与渲染及Diff算法解析 | EsunR-Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?31bd12722efcf47cb7d0d576bf150215";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-3RG97DCL3N"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-3RG97DCL3N');</script><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Parcel-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">1. Parcel 安装与使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-JSX-%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-text">2. JSX 的渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Babel-%E8%BD%AC%E4%B9%89"><span class="toc-text">2.1 Babel 转义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-React-createElement"><span class="toc-text">2.2 React.createElement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-ReactDOM-render"><span class="toc-text">2.3 ReactDOM.render</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. 组件的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%AE%A9-render-%E5%87%BD%E6%95%B0%E6%94%AF%E6%8C%81%E4%BC%A0%E5%85%A5%E7%BB%84%E4%BB%B6"><span class="toc-text">3.1 让 render 函数支持传入组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-createComponent"><span class="toc-text">3.2 createComponent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-setComponentProps"><span class="toc-text">3.3 setComponentProps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-renderComponent"><span class="toc-text">3.4 renderComponent</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4. 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-componentWillMount-%E4%B8%8E-componentDidMount"><span class="toc-text">4.1 componentWillMount 与 componentDidMount</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-componentWillUpdate-%E4%B8%8E-componentDidUpdate"><span class="toc-text">4.2 componentWillUpdate 与 componentDidUpdate</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Diff-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. Diff 算法的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%B5%B7%E6%AD%A5"><span class="toc-text">5.1 起步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.2 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%AF%B9%E6%AF%94%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9"><span class="toc-text">5.3 对比文本节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AF%B9%E6%AF%94%E7%BB%84%E4%BB%B6"><span class="toc-text">5.4 对比组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%AF%B9%E6%AF%94%E9%9D%9E%E6%96%87%E6%9C%ACDOM%E8%8A%82%E7%82%B9"><span class="toc-text">5.5 对比非文本DOM节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-%E5%AF%B9%E6%AF%94%E5%B1%9E%E6%80%A7"><span class="toc-text">5.5.1 对比属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-%E5%AF%B9%E6%AF%94%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-text">5.5.2 对比子节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%BC%82%E6%AD%A5-setState"><span class="toc-text">6. 异步 setState</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%88%9B%E5%BB%BA-setStateQueue-%E4%B8%8E-renderQueue"><span class="toc-text">6.1 创建 setStateQueue 与 renderQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%88%9B%E5%BB%BA%E6%B8%85%E7%A9%BA%E9%98%9F%E5%88%97%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">6.2 创建清空队列的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%AF%BB%E6%89%BE%E5%90%88%E9%80%82%E7%9A%84%E6%9B%B4%E6%96%B0%E6%97%B6%E6%9C%BA"><span class="toc-text">6.3 寻找合适的更新时机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%8F%82%E8%80%83"><span class="toc-text">7. 参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://esunr-webapp.cdn.bcebos.com/blog/avatar.jpeg?x-bce-process=image/resize,m_lfit,w_200/format,f_auto" alt="avatar"></div><div class="author-info__name text-center">EsunR</div><div class="author-info__description text-center">EsunR-Blog是由EsunR维护的博客平台，分享在前端开发、Git、Vue.js、Webpack、OAuth、Linux等各个领域的知识和经验。浏览这里的深入文章，了解不同主题的见解，并及时了解行业的最新趋势和技术。</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/EsunR">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">170</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">151</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">25</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://esunr-webapp.cdn.bcebos.com/blog/background.png?x-bce-process=image/quality,q_80/format,f_auto)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">EsunR-Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><span class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></span></span></div><div id="post-info"><div id="post-title">图文并茂,React组件更新与渲染及Diff算法解析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/React/">React</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/05/6b293d86ef03.html#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/05/6b293d86ef03.html"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">7.5k</span><span class="post-meta__separator">|</span><span>Reading time: 29 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="1-Parcel-安装与使用"><a href="#1-Parcel-安装与使用" class="headerlink" title="1. Parcel 安装与使用"></a>1. Parcel 安装与使用</h1><p>Parcel 是 Web 应用打包工具，适用于经验不同的开发者。它利用多核处理提供了极快的速度，并且不需要任何配置。</p>
<blockquote>
<p>文档：<a target="_blank" rel="noopener" href="https://www.parceljs.cn/getting_started.html">https://www.parceljs.cn/getting_started.html</a></p>
</blockquote>
<p>本地安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add parcel-bundler --dev</span><br></pre></td></tr></table></figure>

<p>安装 babel ，将 jsx 语法转化成 js 对象（虚拟DDM）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/core @babel/plugin-transform-react-jsx @babel/preset-env --dev</span><br></pre></td></tr></table></figure>

<p>配置 .babelrc ：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;evn&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;transform-react-jsx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prama&quot;</span><span class="punctuation">:</span> <span class="string">&quot;React.createElement&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-JSX-的渲染"><a href="#2-JSX-的渲染" class="headerlink" title="2. JSX 的渲染"></a>2. JSX 的渲染</h1><h2 id="2-1-Babel-转义"><a href="#2-1-Babel-转义" class="headerlink" title="2.1 Babel 转义"></a>2.1 Babel 转义</h2><p>先举个例子，当我们编写一个正常的 jsx 文件时，其结构是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;./lib/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;./lib/react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ele = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;active&quot;</span> <span class="attr">title</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    hello,<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &quot;<span class="attr">red</span>&quot; &#125;&#125;&gt;</span>React!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(ele, <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#app&quot;</span>));</span><br></pre></td></tr></table></figure>


<p>其中， babel 会对 jsx 部分进行转义，调用 react 的 <code>createElement</code> 方法去创建虚拟 DOM 树：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;ZhangSan&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;active&quot;</span> <span class="attr">title</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    hello<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &quot;<span class="attr">red</span>&quot; &#125;&#125;&gt;</span>React!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    my name is &#123;flag === true ? name : &quot;LiSi&quot;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Babel 转义后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;ZhangSan&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&quot;active&quot;</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;123&quot;</span></span><br><span class="line">  &#125;, <span class="string">&quot;hello&quot;</span>, <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;React!&quot;</span>), <span class="string">&quot;my name is &quot;</span>, flag === <span class="literal">true</span> ? name : <span class="string">&quot;LiSi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Babel 进行对 jsx 语法的转义过程中，也会对模板语法直接进行转义，调用其中使用的变量</p>
</blockquote>
<p>同样的，我们可以不编写 JSX，直接调用 <code>React.createElement()</code> 方法来生成虚拟 DOM 树，然后再调用 <code>ReactDOM.render()</code> 来渲染虚拟 DOM 树：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;./lib/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;./lib/react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ele = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&quot;active&quot;</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hello,&quot;</span>,</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&quot;span&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">style</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;React!&quot;</span></span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(ele, <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#app&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Babel 转义后由于会转义为 <code>React.createElement</code> 因此必须把 <code>React</code> 引入到当前代码中，这也就是为什么我们即使在代码中并没有用到 <code>React</code> 对象，却仍要引用它的原因。</p>
</blockquote>
<h2 id="2-2-React-createElement"><a href="#2-2-React-createElement" class="headerlink" title="2.2 React.createElement"></a>2.2 React.createElement</h2><p><code>React.createElement</code> 方法会生成一个对象，这个对象包含了将来生成节点的类型、属性、内容（包含子节点），其是一个嵌套的结构，这就形成了一个树形结构，我们便将其称之为 <strong>虚拟DOM树</strong>。</p>
<p>我们先来看下其 API 设计:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(tagName, attribute, ...children)</span><br></pre></td></tr></table></figure>

<p>tag 表示虚拟节点的类型，attribute 表示虚拟节点的属性，children 表示虚拟节点的子节点。这里要注意的是，如果子节点是文本节点，那么会直接传入一个字符串，如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;标题&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>会被 Babel 转化为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;标题&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实现这个方法其实也很简单，我们只需要返回一个对象就可以了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">React</span> = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">tag, attrs, ...children</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    attrs,</span><br><span class="line">    children,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>;</span><br></pre></td></tr></table></figure>

<p>借用最初的例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dom = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;active&quot;</span> <span class="attr">title</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    hello,<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &quot;<span class="attr">red</span>&quot; &#125;&#125;&gt;</span>React!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>经 Babel 转义并使用调用 React.createElement() 后，打印出 dom：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">    <span class="string">&quot;attrs&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;className&quot;</span>: <span class="string">&quot;active&quot;</span>,</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;123&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;hello,&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;span&quot;</span>,</span><br><span class="line">            <span class="string">&quot;attrs&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;style&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;color&quot;</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;React!&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-ReactDOM-render"><a href="#2-3-ReactDOM-render" class="headerlink" title="2.3 ReactDOM.render"></a>2.3 ReactDOM.render</h2><p>React 生成了虚拟 DOM 树，那么 ReactDOM 就需要将虚拟 DOM 树渲染为 html 节点，其核心就是调用 <code>ReactDOM.render</code> 函数。</p>
<p>我们先来看一下 <code>ReactDOM.render</code> 函数的 API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(vnode, container);</span><br></pre></td></tr></table></figure>

<p>其中，vnode 就是虚拟 DOM 树，container 就是由虚拟 DOM 树生成真实 html 节点后，节点挂载的目标父节点，其是一个 HTMLElement。</p>
<p>其实现也并不复杂，只需分如下几步：</p>
<ol>
<li>判断 vnode 类型，如果是字符串，就创建文本节点，并将文本节点挂载到目标父节点中；</li>
<li>如果不是字符串，那就根据 tag 名称，调用 <code>document.createElement</code> 生成真实节点；</li>
<li>为真实节点添加属性；</li>
<li>使用递归，遍历子节点，将当前生成的真实节点作为子节点的目标父节点，调用 render 函数渲染子节点；</li>
<li>调用 <code>appendChild</code> 方法将生成的节点挂载到目标父节点中。</li>
</ol>
<p>代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ReactDOM</span> = &#123; render &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">vnode, container</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 vnode 是字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建文本节点</span></span><br><span class="line">    <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(vnode);</span><br><span class="line">    <span class="keyword">return</span> container.<span class="title function_">appendChild</span>(textNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则就是一个虚拟 DOM 对象</span></span><br><span class="line">  <span class="keyword">const</span> &#123; tag, attrs, children &#125; = vnode;</span><br><span class="line">  <span class="keyword">const</span> dom = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tag);</span><br><span class="line">  <span class="keyword">if</span> (attrs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> attrs) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = attrs[key];</span><br><span class="line">      <span class="title function_">setAttribute</span>(dom, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染子节点</span></span><br><span class="line">  <span class="keyword">if</span> (children &amp;&amp; children <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">    children.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> <span class="title function_">render</span>(child, dom));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> container.<span class="title function_">appendChild</span>(dom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setAttribute</span>(<span class="params">dom, key, value</span>) &#123;</span><br><span class="line">  <span class="comment">// 将属性名 className 转化为 class</span></span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;className&quot;</span>) &#123;</span><br><span class="line">    key = <span class="string">&quot;class&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是事件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/on\w+/</span>.<span class="title function_">test</span>(key)) &#123;</span><br><span class="line">    key = key.<span class="title function_">toLowerCase</span>();</span><br><span class="line">    dom[key] = value || <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是样式</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&quot;style&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 样式是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      dom.<span class="property">style</span>.<span class="property">cssText</span> = value || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 样式是对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">          dom.<span class="property">style</span>[key] = value[key] + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dom.<span class="property">style</span>[key] = value[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他属性直接赋值</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> dom) &#123;</span><br><span class="line">      dom[key] = value || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      dom.<span class="title function_">setAttribute</span>(key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dom.<span class="title function_">removeAttribute</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ReactDOM</span>;</span><br></pre></td></tr></table></figure>

<h1 id="3-组件的实现"><a href="#3-组件的实现" class="headerlink" title="3. 组件的实现"></a>3. 组件的实现</h1><p>在上一节中，我们实现了 render 函数，render 函数的第一个参数可以传入一个虚拟节点。但是，在实际的 React 中，第一个参数还可以传入一个函数组件，因此我们以此为切入点，探讨一下 React 中组件的渲染原理。</p>
<h2 id="3-1-让-render-函数支持传入组件"><a href="#3-1-让-render-函数支持传入组件" class="headerlink" title="3.1 让 render 函数支持传入组件"></a>3.1 让 render 函数支持传入组件</h2><p>我们先来看一下经过 babel 转义的组件 jsx 长什么样子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;active&quot;</span> <span class="attr">title</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      hello, <span class="tag">&lt;<span class="name">span</span>&gt;</span>react<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> title = <span class="string">&quot;active&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Home</span> <span class="attr">name</span>=<span class="string">&#123;title&#125;</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://i.loli.net/2021/04/11/cvX3gjTHPVD1OBI.png" alt=""></p>
<p>我们可以发现，函数组件被处理为虚拟节点对象后，tag 中包含了改组件的渲染函数，因此我们可以通过 render 函数来判断 tag 属性来判断渲染对象到底是 HTMLElement 还是 React 组件，同时我们将 render 函数进行一下简单的拆分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">vnode, container</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> container.<span class="title function_">appendChild</span>(<span class="title function_">_render</span>(vnode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_render</span>(<span class="params">vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode === <span class="literal">undefined</span> || vnode === <span class="literal">null</span> || <span class="keyword">typeof</span> vnode === <span class="string">&quot;boolean&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 如果 tag 是函数，则渲染函数组件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.<span class="property">tag</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建组件</span></span><br><span class="line">    <span class="keyword">const</span> comp = <span class="title function_">createComponent</span>(vnode.<span class="property">tag</span>, vnode.<span class="property">attrs</span>);</span><br><span class="line">    <span class="comment">// 2. 设置组件 props 并渲染组件</span></span><br><span class="line">    <span class="title function_">setComponentProps</span>(com, vnode.<span class="property">attrs</span>);</span><br><span class="line">    <span class="comment">// 3. 组件渲染后的 DOM 对象返回</span></span><br><span class="line">    <span class="keyword">return</span> comp.<span class="property">base</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果 vnode 是字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 否则就是一个虚拟 DOM 对象</span></span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-createComponent"><a href="#3-2-createComponent" class="headerlink" title="3.2 createComponent"></a>3.2 createComponent</h2><p>在 <code>_render()</code> 函数中，如果传入的是一个函数或 class 组件，首先要实现一个 <code>createComponent</code> 方法，来将组件进行 <strong>实例化</strong>，最终的实例化对象上会有一个 <code>render()</code> 方法来生成具体的虚拟 DOM 对象。</p>
<p>以下是 <code>createComponent</code> 方法的具体实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComponent</span>(<span class="params">comp, props</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> inst;</span><br><span class="line">  <span class="keyword">if</span> (comp.<span class="property"><span class="keyword">prototype</span></span> &amp;&amp; comp.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">render</span>) &#123;</span><br><span class="line">    inst = <span class="keyword">new</span> <span class="title function_">comp</span>(props); <span class="comment">// (1)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    inst = <span class="keyword">new</span> <span class="title class_">Component</span>(props); <span class="comment">// (2)</span></span><br><span class="line">    inst.<span class="property">constructor</span> = comp; <span class="comment">// (3)</span></span><br><span class="line">    inst.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">constructor</span>(<span class="params">props</span>);</span><br><span class="line">    &#125;; <span class="comment">// (4)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们传入的是一个 class 组件，那么直接将其进行实例化，<strong>注意此时组件就会执行构造函数的 <code>constructor</code> 部分，如进行 state 的初始化</strong>，最终实例化后的对象上会挂载一个 <code>render</code> 方法（1）；</p>
<p>但如果我们传入的是一个函数组件，我们要将其构造为一个 class 组件，在构造为一个 class 组件之前，我们需要首先声明 <code>Component</code> 类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component.js</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span> = props;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Component</span>;</span><br></pre></td></tr></table></figure>

<p>首先我们实例化一个 <code>Component</code> 对象，作为我们即将改造的“初始对象”，此时要注意将组件属性 <code>props</code> 传入，这样在组件对象上才能取到传入的 <code>props</code>（2）；之后我们将函数组件的函数体挂载到生成的 Component 对象的 <code>constructor</code> 上，我们这一步是改写了生成的 Component 对象的构造方法（3），目前来看意义不大；之后，我们将生成的 Component 对象的 <code>render()</code> 方法改写为函数组件的函数体（4），这样就将一个函数组件改写为了 class 组件。</p>
<h2 id="3-3-setComponentProps"><a href="#3-3-setComponentProps" class="headerlink" title="3.3 setComponentProps"></a>3.3 setComponentProps</h2><p><code>setComponentProps</code> 方法负责对组件的 props 进行更新，并触发组件的渲染：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setComponentProps</span>(<span class="params">comp, props</span>) &#123;</span><br><span class="line">  comp.<span class="property">props</span> = props;</span><br><span class="line">  <span class="title function_">renderComponent</span>(comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实，在目前组件执行初次渲染时 <code>comp.props = props</code> 的执行是没有意义的，因为在执行 <code>createComponent</code> 组件实例化时，就已经完成了对 props 的挂载。我们在这里再重新挂载一次是因为该方法不仅在组件初始化时调用，也会在组件更新时调用。当组件更新时，直接调用该方法就可以直接完成 props 的更新以及组件的重新渲染。</p>
</blockquote>
<h2 id="3-4-renderComponent"><a href="#3-4-renderComponent" class="headerlink" title="3.4 renderComponent"></a>3.4 renderComponent</h2><p>在调用 <code>renderComponent</code> 之前，我们已经完成了对函数组件、class 组件的实例化，并且将外部传入的组件属性挂载到了实例化对象的 <code>props</code> 属性上，同时实例化好的组件对象上有用 <code>render()</code> 方法，执行后可以返回一个虚拟节点对象。</p>
<p>因此，在 <code>renderComponent</code> 方法中，我们主要是调用组件的 <code>render()</code> 函数（1），然后再将生成的虚拟节点对象传入到 <code>_render()</code> 函数中，渲染为真实的 DOM 对象，并将 DOM 对象挂载到组件实例的 base 属性上（2）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderComponent</span>(<span class="params">comp</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> renderer = comp.<span class="title function_">render</span>(); <span class="comment">// (1)</span></span><br><span class="line">  comp.<span class="property">base</span> = <span class="title function_">_render</span>(renderer); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. 生命周期</h1><p>在上一节中，我们已经完善了组件的渲染过程，那么在本章节中，我们将还原 React 组件<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle">生命周期函数</a>的调用过程。我们将着重探讨 <code>componentWillMount</code> <code>componentDidMount</code> <code>componentWillUpdate</code> <code>componentDidUpdate</code> 这四个生命周期函数。</p>
<h2 id="4-1-componentWillMount-与-componentDidMount"><a href="#4-1-componentWillMount-与-componentDidMount" class="headerlink" title="4.1 componentWillMount 与 componentDidMount"></a>4.1 componentWillMount 与 componentDidMount</h2><blockquote>
<p>UNSAFE_componentWillMount() 在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。</p>
</blockquote>
<p>根据以上的特性我们很容易判断出 <code>componentWillMount</code> 的执行位置，让其在 <code>renderComponent()</code> 之前执行并且仅执行一次即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_render</span>(<span class="params">vnode</span>) &#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.<span class="property">tag</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> comp = <span class="title function_">createComponent</span>(vnode.<span class="property">tag</span>, vnode.<span class="property">attrs</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!comp.<span class="property">base</span>) &#123;</span><br><span class="line">      comp?.<span class="title function_">componentWillMount</span>();</span><br><span class="line">    &#125; <span class="comment">// 执行 componentWillMount</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">renderComponent</span>(comp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> comp.<span class="property">base</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</p>
</blockquote>
<p><code>componentDidMount</code> 要在组件完成挂载时执行，且只执行一次，那么在 <code>renderComponent</code> 过程中，我们可以将其放置在组件渲染完成并且是初次挂载时执行。</p>
<blockquote>
<p>!!! 此处教程有误，componentDidMount 应该在组件 DOM 挂载到页面上后再执行，按照下面的写法显然实在 DOM 被挂载之前执行  !!!</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderComponent</span>(<span class="params">comp</span>) &#123;</span><br><span class="line">  <span class="comment">// 对组件进行渲染，获取虚拟节点对象</span></span><br><span class="line">  <span class="keyword">const</span> renderer = comp.<span class="title function_">render</span>();</span><br><span class="line">  <span class="keyword">let</span> base = <span class="title function_">_render</span>(renderer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!comp.<span class="property">base</span>) &#123;</span><br><span class="line">    comp?.<span class="title function_">componentDidMount</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  comp.<span class="property">base</span> = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-componentWillUpdate-与-componentDidUpdate"><a href="#4-2-componentWillUpdate-与-componentDidUpdate" class="headerlink" title="4.2 componentWillUpdate 与 componentDidUpdate"></a>4.2 componentWillUpdate 与 componentDidUpdate</h2><p>要执行这两个方法，我们首先要实现组件内部 state 的更新以及重新渲染，我们先编写一个如下的 demo 组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Handle</span></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello, react!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          Click me! (&#123;this.state.num&#125;)</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/04/14/3aBXAwJmQlzVtKx.png" alt=""></p>
<p>当用户点击按钮后，state 中存放的 num 变量就会被加一，然后页面会触发重新渲染，来展示整个页面。</p>
<p>要实现 state 的变更以及重新渲染，我们首先要扩展一下 Component 组件：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ import &#123; renderComponent &#125; from &quot;../react-dom/index&quot;;</span></span><br><span class="line"></span><br><span class="line">  class Component &#123;</span><br><span class="line">    constructor(props = &#123;&#125;) &#123;</span><br><span class="line">      this.props = props;</span><br><span class="line">      this.state = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   setState(stateChange) &#123;</span></span><br><span class="line"><span class="addition">+     Object.assign(this.state, stateChange); // (1)</span></span><br><span class="line"><span class="addition">+     renderComponent(this); // (2)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">export default Component;</span><br></pre></td></tr></table></figure>

<p>我们为 <code>Component</code> 添加 <code>setState</code> 方法，此时我们为了方便编写 demo，只是简单的将 state 进行了浅拷贝并覆盖值（1），实际的 setState 操作是异步的。进行了赋值操作之后，我们重新调用 <code>renderComponent</code> 方法对组件进行重新渲染，并将当前组件作为渲染对象传入（2）。</p>
<p>此时我们点击按钮后，会发现页面上的 DOM 结构并不会改变，但是在 <code>renderComponent</code> 方法中打印出当前的组件对象，其 base 上挂载的 HTMLElement 的确是已经发生了更新，这就说明我们并没有将更新后的 HTMLElement 挂载到页面上。</p>
<p>更新节点的方法其实也很简单，我们只需要获取到当前组件的父节点，然后使用 <code>replaceChild()</code> 方法，替换父节点的内容为最新的组件节点就可以了（1）。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  export function renderComponent(comp) &#123;</span><br><span class="line">    // 对组件进行渲染，获取虚拟节点对象</span><br><span class="line">    const renderer = comp.render();</span><br><span class="line">    let base = _render(renderer);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   // 节点替换</span></span><br><span class="line"><span class="addition">+   if (comp?.base?.parentNode) &#123;</span></span><br><span class="line"><span class="addition">+     comp.base.parentNode.replaceChild(base, comp.base); // (1)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"></span><br><span class="line">    comp.base = base;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们根据 <code>componentWillUpdate</code> 与 <code>componentDidUpdate</code> 的定义，就很容易得知其执行的位置：</p>
<blockquote>
<p>当组件收到新的 props 或 state 时，会在渲染之前调用 UNSAFE_componentWillUpdate()。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。</p>
</blockquote>
<blockquote>
<p>componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  export function renderComponent(comp) &#123;</span><br><span class="line">    const renderer = comp.render();</span><br><span class="line">    let base = _render(renderer);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   if (comp.base) &#123;</span></span><br><span class="line"><span class="addition">+     comp?.componentWillUpdate(comp.props, comp.state);</span></span><br><span class="line"><span class="addition">+   &#125; else &#123;</span></span><br><span class="line"><span class="addition">+     comp.base = base; // 组件必须在挂载后再触发 componentDidMount</span></span><br><span class="line"><span class="addition">+     comp?.componentDidMount();</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"></span><br><span class="line">    if (comp?.base?.parentNode) &#123;</span><br><span class="line">      comp.base.parentNode.replaceChild(base, comp.base);</span><br><span class="line"><span class="addition">+     comp.base = base;</span></span><br><span class="line"><span class="addition">+     comp?.componentDidUpdate();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   comp.base = base;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-Diff-算法的实现"><a href="#5-Diff-算法的实现" class="headerlink" title="5. Diff 算法的实现"></a>5. Diff 算法的实现</h1><p>截至目前，我们已经刨析了 jsx 的渲染以及组件 state 的更新，那么接下来我们会进一步对渲染流程进行优化。</p>
<p>在前面的写法中，每当 state 改变触发组件重新渲染时，都会从头开始进行渲染，这样对性能的损耗是很大的。为了优化 DOM 结构的更新性能，react 引入了 diff 算法，这个算法会对比每个<strong>同级节点的变更</strong>，如果当前节点与之前相较发生了变更，就会更新当前节点与其子节点，这比重新渲染整个 DOM 结构要高效的多。</p>
<p><img src="https://i.loli.net/2021/04/24/fZUiX1TAMw2aI8F.png" alt=""></p>
<p>总而言之,我们的diff算法有两个原则：</p>
<ul>
<li>对比当前真实的DOM和虚拟DOM,在对比过程中直接更新真实DOM</li>
<li>只对比同一层级的变化</li>
</ul>
<h2 id="5-1-起步"><a href="#5-1-起步" class="headerlink" title="5.1 起步"></a>5.1 起步</h2><p>先修改render函数,将_render方法渲染的方式改为我们即将写的diff算法方式</p>
<p><code>/react-dom/index.js</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> diff <span class="keyword">from</span> <span class="string">&#x27;./diff&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactDOM</span> = &#123;</span><br><span class="line">    render</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">vnode, container</span>) &#123;</span><br><span class="line">    <span class="comment">// return container.appendChild(_render(vnode));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">diff</span>(dom,vnode,container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的<code>diff()</code>可以看出,传入了 <code>真实DOM对象,虚拟DOM对象,根元素</code></p>
<h2 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h2><p>实现一个diff算法,它的作用是对比真实的DOM和虚拟DOM,最后返回更新后的DOM</p>
<p><code>/react-dom/diff.js</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dom:真实DOM</span></span><br><span class="line"><span class="comment">vnode:虚拟DOM</span></span><br><span class="line"><span class="comment">container: 容器</span></span><br><span class="line"><span class="comment">return : 更新后的DOM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">diff</span>(<span class="params">dom,vnode,container</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回更新后的节点</span></span><br><span class="line">    <span class="keyword">let</span> ret =  <span class="title function_">diffNode</span>(dom,vnode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">diffNode</span>(<span class="params">dom,vnode</span>)&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来实现这个方法</p>
<p>在这之前先来回忆一下我们虚拟DOM的结构:</p>
<p>虚拟DOM的结构可以分为三种,分别表示文本,原生DOM节点以及组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生DOM节点的vnode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="attr">attrs</span>: &#123;</span><br><span class="line">        <span class="attr">className</span>: <span class="string">&#x27;container&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">children</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本节点的vnode</span></span><br><span class="line"><span class="string">&quot;hello,world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件的vnode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="title class_">ComponentConstrucotr</span>,</span><br><span class="line">    <span class="attr">attrs</span>: &#123;</span><br><span class="line">        <span class="attr">className</span>: <span class="string">&#x27;container&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">children</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-对比文本节点"><a href="#5-3-对比文本节点" class="headerlink" title="5.3 对比文本节点"></a>5.3 对比文本节点</h2><p>首先考虑最简单的文本节点,如果当前的DOM就是文本节点,则直接更新内容,否则就新建一个文本节点,并移除原来的DOM</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">diffNode</span>(<span class="params">dom,vnode</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> out = dom;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> vnode === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// 如果当前的dom是文本节点,则直接更新内容</span></span><br><span class="line">      <span class="keyword">if</span>(dom &amp;&amp; dom.<span class="property">nodeType</span> === <span class="number">3</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(dom.<span class="property">textContent</span> !== vnode) dom.<span class="property">textContent</span> = vnode;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//  如果dom不是文本节点,则新建一个文本节点dom,并移除原来的dom</span></span><br><span class="line">        out = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(vnode);</span><br><span class="line">        <span class="keyword">if</span>(dom &amp;&amp; dom.<span class="property">parentNode</span>)&#123;</span><br><span class="line">            dom.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(out,dom);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文本节点十分简单,它没有属性,也没有子元素</p>
<h2 id="5-4-对比组件"><a href="#5-4-对比组件" class="headerlink" title="5.4 对比组件"></a>5.4 对比组件</h2><p>之前也说过,react组件分为函数组件和类组件,我们定制一个方法<code>diffComponent</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> setComponentProps <span class="keyword">from</span> <span class="string">&quot;./index.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">diffNode</span>(<span class="params">dom,vnode</span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//如果是一个组件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.<span class="property">tag</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">diffComponent</span>(dom, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">diffComponent</span>(<span class="params">dom, vnode</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> comp = dom;</span><br><span class="line">    <span class="comment">// 如果组件没有变化,则重新设置 props;   执行</span></span><br><span class="line">    <span class="keyword">if</span> (comp &amp;&amp; comp.<span class="property">constructor</span> === vnode.<span class="property">tag</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新设置 props 并渲染</span></span><br><span class="line">        <span class="title function_">setComponentProp</span>(comp, vnode.<span class="property">attrs</span>);</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        dom = comp.<span class="property">base</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果组件类型变化,则移除掉原来组件,并渲染新组件</span></span><br><span class="line">        <span class="comment">// 移除</span></span><br><span class="line">        <span class="keyword">if</span> (comp) &#123;</span><br><span class="line">            <span class="title function_">unmountComponent</span>(comp);</span><br><span class="line">            comp = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//核心代码</span></span><br><span class="line">        <span class="comment">// 1.创建新组件</span></span><br><span class="line">        comp = <span class="title function_">createComponent</span>(vnode.<span class="property">tag</span>, vnode.<span class="property">attrs</span>);</span><br><span class="line">        <span class="comment">// 2.设置组件属性</span></span><br><span class="line">        <span class="title function_">setComponentProp</span>(comp, vnode.<span class="property">attrs</span>);</span><br><span class="line">        dom = comp.<span class="property">base</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-对比非文本DOM节点"><a href="#5-5-对比非文本DOM节点" class="headerlink" title="5.5 对比非文本DOM节点"></a>5.5 对比非文本DOM节点</h2><p>如果vnode表示的是一个非文本DOM节点,分两种情况分析:</p>
<p>情况一: 如果真实DOM不存在,表示此节点是新增的</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!dom)&#123;</span><br><span class="line">    updateDOM = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">tag</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况二:如果真实DOM存在,需要<code>对比属性</code>和<code>对比子节点</code></p>
<h3 id="5-5-1-对比属性"><a href="#5-5-1-对比属性" class="headerlink" title="5.5.1 对比属性"></a>5.5.1 对比属性</h3><p>找出来节点的属性以及事件监听的变化 单独起一个<code>diffAttributes</code>方法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置属性和移除属性的时候 使用到了此方法.注意:移除属性 只需要设置属性值为undefined就可以</span></span><br><span class="line"><span class="keyword">import</span> &#123; setAttribute &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">diffNode</span>(<span class="params">dom,vnode</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> out = dom;</span><br><span class="line">	  <span class="comment">//  ....</span></span><br><span class="line">    <span class="comment">// 如果是非文本DOM节点</span></span><br><span class="line">    <span class="comment">// 真实DOM不存在</span></span><br><span class="line">    <span class="keyword">if</span>(!dom)&#123;</span><br><span class="line">      out = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">tag</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">    <span class="comment">// 如果真实DOM存在,需要对比属性和对比子节点</span></span><br><span class="line">    <span class="title function_">diffAttributes</span>(out,vnode);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">diffAttributes</span>(<span class="params">dom, vnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存之前的真实DOM的所有属性</span></span><br><span class="line">    <span class="keyword">const</span> oldAttrs = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> newAttrs = vnode.<span class="property">attrs</span>; <span class="comment">//虚拟DOM的属性 (也是最新的属性)</span></span><br><span class="line">    <span class="comment">// 获取真实DOM属性</span></span><br><span class="line">    <span class="keyword">const</span> domAttrs = dom.<span class="property">attributes</span>;</span><br><span class="line">    <span class="comment">// const domAttrs =  document.querySelector(&#x27;#root&#x27;).attributes;</span></span><br><span class="line">    [...domAttrs].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        oldAttrs[item.<span class="property">name</span>] = item.<span class="property">value</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="comment">// 如果原来的属性不在新的属性当中,则将其移除掉  (属性值直接设置undefined)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldAttrs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> newAttrs)) &#123;</span><br><span class="line">            <span class="comment">// 移除</span></span><br><span class="line">            <span class="title function_">setAttribute</span>(dom, key, <span class="literal">undefined</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新新的属性值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> newAttrs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldAttrs[key] !== newAttrs[key]) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(dom, newAttrs[key], key);</span><br><span class="line">            <span class="comment">// 只更值不相等的属性</span></span><br><span class="line">            <span class="title function_">setAttribute</span>(dom, key, newAttrs[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-2-对比子节点"><a href="#5-5-2-对比子节点" class="headerlink" title="5.5.2 对比子节点"></a>5.5.2 对比子节点</h3><p>节点对比完成之后,接下来对比它的子节点</p>
<p>这个时候会有一个问题,前面我们实现的不同的diff算法,都是明确知道哪一个是真实DOM和虚拟DOM对比,但是子节点childrens是一个数组,他们可能改变顺序,或者数量有所变化,我们很难确定是和虚拟DOM对比的是哪一个?</p>
<blockquote>
<p>思路:给节点设置一个key值,重新渲染时对比key值相同的节点,这样我们就能找到真实DOM和哪个虚拟DOM进行对比了</p>
</blockquote>
<p>对比子节点的方法有点复杂,在这里理解一下原理</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">diffNode</span>(<span class="params">dom,vnode</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (vnode.<span class="property">childrens</span> &amp;&amp; vnode.<span class="property">childrens</span>.<span class="property">length</span> &gt; <span class="number">0</span> || (out.<span class="property">childNodes</span> &amp;&amp; out.<span class="property">childNodes</span>.<span class="property">length</span> &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="title function_">diffChildren</span>(out, vnode.<span class="property">childrens</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">diffChildren</span>(<span class="params">dom, vchildren</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> domChildren = dom.<span class="property">childNodes</span>;</span><br><span class="line">  <span class="keyword">const</span> children = [];</span><br><span class="line">  <span class="keyword">const</span> keyed = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将有key的节点(用对象保存)和没有key的节点(用数组保存)分开</span></span><br><span class="line">  <span class="keyword">if</span> (domChildren.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    [...domChildren].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取key</span></span><br><span class="line">      <span class="keyword">const</span> key = item.<span class="property">key</span>;</span><br><span class="line">      <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="comment">// 如果key存在,保存到对象中</span></span><br><span class="line">        keyed[key] = item;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果key不存在,保存到数组中</span></span><br><span class="line">        children.<span class="title function_">push</span>(item);<span class="string">``</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vchildren &amp;&amp; vchildren.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> childrenLen = children.<span class="property">length</span>; <span class="comment">//2</span></span><br><span class="line">    [...vchildren].<span class="title function_">forEach</span>(<span class="function">(<span class="params">vchild, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取虚拟DOM中所有的key</span></span><br><span class="line">      <span class="keyword">const</span> key = vchild.<span class="property">key</span>;</span><br><span class="line">      <span class="keyword">let</span> child;</span><br><span class="line">      <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="comment">// 如果有key,找到对应key值的节点</span></span><br><span class="line">        <span class="keyword">if</span> (keyed[key]) &#123;</span><br><span class="line">          child = keyed[key];</span><br><span class="line">          keyed[key] = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLen &gt; min) &#123;</span><br><span class="line">        <span class="comment">// 如果没有key,则优先找类型相同的节点</span></span><br><span class="line">        <span class="comment">// 遍历所有真实节点的子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = min; j &lt; childrenLen; j++) &#123;</span><br><span class="line">          <span class="keyword">let</span> c = children[j];</span><br><span class="line">          <span class="keyword">if</span> (c) &#123;</span><br><span class="line">            child = c;</span><br><span class="line">            children[j] = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">if</span> (j === childrenLen - <span class="number">1</span>) &#123;</span><br><span class="line">              childrenLen--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j === min) &#123;</span><br><span class="line">              min++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对比</span></span><br><span class="line">      child = <span class="title function_">diffNode</span>(child, vchild);</span><br><span class="line">      <span class="comment">// 更新DOM</span></span><br><span class="line">      <span class="keyword">const</span> f = domChildren[i];</span><br><span class="line">      <span class="keyword">if</span> (child &amp;&amp; child !== dom &amp;&amp; child !== f) &#123;</span><br><span class="line">        <span class="comment">// 如果更新前的对应位置为空，说明此节点是新增的</span></span><br><span class="line">        <span class="keyword">if</span> (!f) &#123;</span><br><span class="line">          dom.<span class="title function_">appendChild</span>(child);</span><br><span class="line">          <span class="comment">// 如果更新后的节点和更新前对应位置的下一个节点一样，说明当前位置的节点被移除了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child === f.<span class="property">nextSibling</span>) &#123;</span><br><span class="line">          dom.<span class="title function_">removeChild</span>(f);</span><br><span class="line">          <span class="comment">// 将更新后的节点移动到正确的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 注意insertBefore的用法，第一个参数是要插入的节点，第二个参数是已存在的节点</span></span><br><span class="line">          dom.<span class="title function_">insertBefore</span>(child, f);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个流程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/ZH2CcJqKeiDtBu3.png" alt=""></p>
<p>最后再修改<code>renderComponent</code>方法的两个地方</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  export function renderComponent(comp) &#123;</span><br><span class="line"><span class="addition">+   let base</span></span><br><span class="line">    // 对组件进行渲染，获取虚拟节点对象</span><br><span class="line">    const renderer = comp.render();</span><br><span class="line"><span class="deletion">-   let base = _render(renderer);</span></span><br><span class="line"></span><br><span class="line">    if (comp.base) &#123;</span><br><span class="line">      // 组件更新时引发重新渲染</span><br><span class="line">      comp?.componentWillUpdate(comp.props, comp.state);</span><br><span class="line"><span class="addition">+     base = diffNode(comp.base,renderer);</span></span><br><span class="line">      comp.base = base;</span><br><span class="line"><span class="addition">+     comp?.componentDidUpdate();</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 初次渲染</span><br><span class="line"><span class="addition">+     base = _render(renderer);</span></span><br><span class="line">      comp.base = base;</span><br><span class="line">      comp?.componentDidMount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   // 组件 state 发生变化后，重新渲染节点，需要进行节点替换</span></span><br><span class="line"><span class="deletion">-   if (comp?.base?.parentNode) &#123;</span></span><br><span class="line"><span class="deletion">-     comp.base.parentNode.replaceChild(base, comp.base);</span></span><br><span class="line"><span class="deletion">-     comp?.componentDidUpdate();</span></span><br><span class="line"><span class="deletion">-   &#125;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-异步-setState"><a href="#6-异步-setState" class="headerlink" title="6. 异步 setState"></a>6. 异步 setState</h1><p>在 React 中，为了优化性能 <code>setState</code> 的操作是异步的，当我们在一个 for 循环中直行 setState，会出现以下情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果始终为初始化的 state 值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 且最终 state.num 的值为 1</span></span><br></pre></td></tr></table></figure>

<p>同时 <code>setState</code> 也支持传入一个函数，在该函数中，可以获取到上一次更新 state 后的状态（prevState）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(prevState.<span class="property">num</span>);       </span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        num : prevState.<span class="property">num</span> + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果可以获取到每次 state 改变前的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 且最终 state.num 的值为 5</span></span><br></pre></td></tr></table></figure>

<p>之所以会这样，是因为 <code>setState</code> 始终是一个异步的操作，此时在循环中取到的 state 都是在循环执行时获取到的组件 state。但是 <code>setState</code> 中如果传入一个函数，那么在函数中可以获取到上次组件更新的 prevState，也就是在传入函数执行时，组件最新的 state，这的确很神奇。</p>
<p>那么知道的上述的具体表现后，我们再来探讨一下为什么 <code>setState</code> 要是一个异步操作，其是怎么优化的，其主要分如下几步：</p>
<ol>
<li>当 react 进行 setState 操作时，会重新渲染组件，渲染组件会消耗大量的性能，为了减少性能损耗，react 会将 <strong>当前同步任务队列</strong> 中的所有 setState 操作都暂存在一个 <strong>执行队列</strong> 中，我们将其定为 <code>setStateQueue</code>，但并不立即执行。同时创建一个 <strong>渲染队列</strong>，将要改变 state 的组件全部存放在渲染队列中，同时 <strong>合并渲染队列中重复的组件</strong>；</li>
<li>等待一段时间过后，react 会将直行队列 <code>setStateQueue</code> 中的 setState 操作，但此时只会改组件的 state ，组件并没有直行实质性的渲染；</li>
<li>等 <code>setStateQueue</code> 队列执行完毕之后，开始对渲染队列 <code>renderQueue</code> 的组件直行渲染操作，这样就可以实现改变多个 state 但只渲染一次，从而优化性能。</li>
</ol>
<p><img src="https://i.loli.net/2021/05/15/RUuTtpSdBAfiv74.jpg" alt="整体流程"></p>
<h2 id="6-1-创建-setStateQueue-与-renderQueue"><a href="#6-1-创建-setStateQueue-与-renderQueue" class="headerlink" title="6.1 创建 setStateQueue 与 renderQueue"></a>6.1 创建 setStateQueue 与 renderQueue</h2><p><code>setStateQueue</code> 负责存储该轮更新时执行的 setState 操作，<code>renderQueue</code> 负责存储在该轮更新后应该渲染的组件。我们要创建这两个队列，并创建加入队列的方法 <code>enqueueSetState(stateChange, component)</code>，并在组件更新 state 时调用该方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set_state_queue.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setStateQueue = [];</span><br><span class="line"><span class="keyword">const</span> renderQueue = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">enqueueSetState</span>(<span class="params">stateChange, component</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 将改变 state 的操作添加到 setStateQueue 中</span></span><br><span class="line">  setStateQueue.<span class="title function_">push</span>(&#123;</span><br><span class="line">    stateChange,</span><br><span class="line">    component,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 将需要改变 state 并渲染的组件添加到 renderQueue 中</span></span><br><span class="line">  <span class="comment">// 此时会直行一个去重操作，如果 renderQueue 里没有当前组件，才添加到队列中</span></span><br><span class="line">  <span class="keyword">let</span> r = renderQueue.<span class="title function_">some</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item === component;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!r) &#123;</span><br><span class="line">    renderQueue.<span class="title function_">push</span>(component);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; enqueueSetState &#125; <span class="keyword">from</span> <span class="string">&quot;./set_state_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span> = props;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">stateChange</span>) &#123;</span><br><span class="line">    <span class="comment">// 旧方法：每次更新 state 都直行渲染组件的操作</span></span><br><span class="line">    <span class="comment">// Object.assign(this.state, stateChange);</span></span><br><span class="line">    <span class="comment">// renderComponent(this);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新方法：每次更新 state 都调用 enqueueSetState 方法，并将 stateChange 与组件传入该方法，让其负责判断组件更新的时机</span></span><br><span class="line">    <span class="title function_">enqueueSetState</span>(stateChange, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Component</span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-创建清空队列的方法"><a href="#6-2-创建清空队列的方法" class="headerlink" title="6.2 创建清空队列的方法"></a>6.2 创建清空队列的方法</h2><p>假设我们已经等待了 <strong>一定的时间</strong>，到达了某一时刻，那么我们就要清空 setStateQueue 与 renderQueue 了。因此我们要创建一个清空队列的方法，将其命名为 flush：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set_state_queue.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flush</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> item;</span><br><span class="line">  <span class="comment">// 遍历state</span></span><br><span class="line">  <span class="keyword">while</span> ((item = setStateQueue.<span class="title function_">shift</span>())) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; stateChange, component &#125; = item;</span><br><span class="line">    <span class="comment">// 如果没有prevState,则将当前的state作为初始的prevState</span></span><br><span class="line">    <span class="keyword">if</span> (!component.<span class="property">prevState</span>) &#123;</span><br><span class="line">      component.<span class="property">prevState</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, component.<span class="property">state</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果stateChange是一个方法,也就是setState的第一种形式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> stateChange === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">        component.<span class="property">state</span>,</span><br><span class="line">        <span class="title function_">stateChange</span>(component.<span class="property">prevState</span>, component.<span class="property">props</span>)</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果stateChange是一个对象,则直接合并到setState中</span></span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(component.<span class="property">state</span>, stateChange);</span><br><span class="line">    &#125;</span><br><span class="line">    component.<span class="property">prevState</span> = component.<span class="property">state</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历组件</span></span><br><span class="line">  <span class="keyword">let</span> component;</span><br><span class="line">  <span class="keyword">while</span> ((component = renderQueue.<span class="title function_">shift</span>())) &#123;</span><br><span class="line">    <span class="title function_">renderComponent</span>(component);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该清空队列的方法实际上就是实现了我们前面原理分析的第 2 与第 3 步操作：</p>
<p><img src="https://i.loli.net/2021/05/15/ZCkT1yIizLpEmND.jpg" alt=""></p>
<h2 id="6-3-寻找合适的更新时机"><a href="#6-3-寻找合适的更新时机" class="headerlink" title="6.3 寻找合适的更新时机"></a>6.3 寻找合适的更新时机</h2><p>前面我们一直在强调 setState 是一个异步操作，其原因就在这儿，我们虽然将所有的 setState 行为已经组件都存放在队列里了，但最重要是寻找到一个时间点去清空队列。这个时间点既不能太快（要后置于当前 JS 的同步任务），又不能太慢（保证让用户无感知）。</p>
<p>最简单的我们就使用一个定时器来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">enqueueSetState</span>(<span class="params">stateChange, component</span>) &#123;</span><br><span class="line">  <span class="comment">// 0. 如果setStateQueue的长度是0,也就是在上次flush执行之后第一次往队列里添加</span></span><br><span class="line">  <span class="keyword">if</span> (setStateQueue.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">flush</span>();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setStateQueue.push &amp; renderQueue.push ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当更新队列为空时，我们开启定时器，由于定时器是一个异步任务，后面更新 setStateQueue 与 renderQueue 的操作会继续执行。同时需要添加一个判断队列是否为空时候才开启定时器，保证开启定时器的操作只在“一轮更新”的最开始直行，只要是在该轮直行的 enqueueSetState 操作都不会在开启定时器，保证了定时器的唯一性。</p>
<p>当定时器到达时间阈值时，标志着该轮更新“到点了”，开始清空队列并执行渲染操作，后续再有更新 state 操作的话就会被延迟到“下一轮”更新中。</p>
<p><img src="https://i.loli.net/2021/05/15/EiIrR9UlcFAby5L.png" alt=""></p>
<p>当然，使用定时器的方法并不是最优雅的，某些浏览器 <code>setTimeout</code> 的最小触发时间为 4ms，如果我们只想同步任务直行完成之后就直行组件更新，连 4ms 都不想等，或者说总是想要优先于主任务队列中的所有 <code>setTimeout</code> 行为的话，该怎么办呢？</p>
<p>这时候就要利用到任务轮询中的 <strong>微任务</strong> 了，这也是微任务的应用点之一。我们都知道微任务属于异步任务，会延后于同步任务队列，但是又会优先于宏任务队列，而 <code>Promise.resolve().then()</code> 是一个最典型的微任务，那么我们只需要将 <code>setTimeout</code> 改成微任务就行了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">enqueueSetState</span>(<span class="params">stateChange, component</span>) &#123;</span><br><span class="line">  <span class="comment">// 0. 如果setStateQueue的长度是0,也就是在上次flush执行之后第一次往队列里添加</span></span><br><span class="line">  <span class="keyword">if</span> (setStateQueue.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(flush);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setStateQueue.push &amp; renderQueue.push ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，我们就不会跟其他的 setTimeout 行为发生冲突了，也可以利用这点来让某些行为在组件更新后发生，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Handle</span></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 利用 setTimeout 将打印行为延后到组件更新完成后直行</span></span><br><span class="line">      <span class="comment">// 此时可以获取到按钮的最新文本内容</span></span><br><span class="line">      <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn: &quot;</span>, btn.<span class="property">innerHTML</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click me! (&#123;this.state.num&#125;)</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h1><p>本文主要参考如下视频与文章，以及 React 官网以及具体源码，结合一些个人理解而编写：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cE411B7by?from=search&seid=5214127956231478250">React 源码实现</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6869549410875867144#heading-23">都快2021年了，你竟然还不知道React的JSX和diff算法？</a></li>
</ul>
<blockquote>
<p>配套源码：<a target="_blank" rel="noopener" href="https://github.com/EsunR/Study-Book/tree/master/React/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">https://github.com/EsunR/Study-Book/tree/master/React/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></p>
</blockquote>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">源码解析</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-62c7f2684e36ba34" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/2d8c057077e7.html"><i class="fa fa-chevron-left">  </i><span>Vue3新特性初探与对比</span></a></div><div class="next-post pull-right"><a href="/2020/12/a1ff30679888.html"><span>Canvas实现空间内反复回弹的小球</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://blog.esunr.site/2021/05/6b293d86ef03.html';
  this.page.identifier = '2021/05/6b293d86ef03.html';
  this.page.title = '图文并茂,React组件更新与渲染及Diff算法解析';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'esunr-blog' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://esunr-blog.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://esunr-webapp.cdn.bcebos.com/blog/background.png?x-bce-process=image/quality,q_80/format,f_auto)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2025 By EsunR</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>