<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="TypeScript 类型体操通关记录"><meta name="keywords" content="Typescript"><meta name="author" content="EsunR"><meta name="copyright" content="EsunR"><title>TypeScript 类型体操通关记录 | EsunR-Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?31bd12722efcf47cb7d0d576bf150215";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-3RG97DCL3N"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-3RG97DCL3N');</script><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95"><span class="toc-text">1. 简单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pick"><span class="toc-text">Pick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exclude"><span class="toc-text">Exclude</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8F%AA%E8%AF%BB"><span class="toc-text">实现对象属性只读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">元组转换为对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">第一个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-text">获取元组长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Awaited"><span class="toc-text">Awaited</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#If"><span class="toc-text">If</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Concat"><span class="toc-text">Concat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Includes"><span class="toc-text">Includes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Push"><span class="toc-text">Push</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parameters"><span class="toc-text">Parameters</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://esunr-webapp.cdn.bcebos.com/blog/avatar.jpeg?x-bce-process=image/resize,m_lfit,w_200/format,f_auto" alt="avatar"></div><div class="author-info__name text-center">EsunR</div><div class="author-info__description text-center">EsunR-Blog是由EsunR维护的博客平台，分享在前端开发、Git、Vue.js、Webpack、OAuth、Linux等各个领域的知识和经验。浏览这里的深入文章，了解不同主题的见解，并及时了解行业的最新趋势和技术。</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/EsunR">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">170</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">151</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">25</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://esunr-webapp.cdn.bcebos.com/blog/background.png?x-bce-process=image/quality,q_80/format,f_auto)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">EsunR-Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><span class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></span></span></div><div id="post-info"><div id="post-title">TypeScript 类型体操通关记录</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-02-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/Javascript/">Javascript</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2024/02/467da063c417.html#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2024/02/467da063c417.html"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.9k</span><span class="post-meta__separator">|</span><span>Reading time: 16 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="1-简单"><a href="#1-简单" class="headerlink" title="1. 简单"></a>1. 简单</h1><h2 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h2><p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00004-easy-pick/README.zh-CN.md">Source</a></p>
<p><code>Pick</code> 是 TypeScript 中的一个内置工具类型，可以从某个类型中提取出来几个特定的属性 Key 来创建一个新的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">completed</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoPreview</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Todo</span>, <span class="string">&quot;title&quot;</span> | <span class="string">&quot;completed&quot;</span>&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">TodoPreview</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Clean room&quot;</span>,</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyPick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> K]: T[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析 ：</p>
<p><code>keyof T</code> 可以将目标类型的 Key 全部提取出来，以上面的示例为例，<code>keyof T</code> 的结果就是 <code>&quot;title&quot; | &quot;description&quot; | &quot;completed&quot;</code>；</p>
<p><code>extends</code> 是 TypeScript 中的一个 <strong>操作类型</strong>，可以用作条件<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">类型判断</a>，意思表述为 <code>extends</code> 左侧的类型可以赋给右侧的类型，如 <code>number extends (number | string) ? number : string // number</code>。在上述示例中，<code>K extends keyof T</code> 就表示为 <code>K</code> 是 <code>&quot;title&quot; | &quot;description&quot; | &quot;completed&quot;</code> 其中的一个值；</p>
<p><code>in</code> 关键词可以帮助我们在定义对象的 key 值时从联合类型中进行取值，如我们想创建一个 Object 的类型声明，该对象的值不限定类型，然而 key 值我们期望限定范围在 <code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code>，那么我们就可以声明该对象的类型为 <code>type Obj = &#123; [key in &#39;a&#39; | &#39;b&#39; | &#39;c&#39;]: string &#125;</code>（如果 key 值也不限定类型，可以直接声明为 <code>&#123; [key: string]: any &#125;</code> 等同于 <code>Record&lt;string, any&gt;</code>）;</p>
<p>因此，使用 <code>K extends keyof T</code> 可以限定泛型的第二个参数位必须传入目标对象的 key，使用 <code>[key in K]: T[key]</code> 来定义一个新的类型声明对象的 Key 和 Value 的类型定义，从而实现 <code>Pick</code> 函数。</p>
<h2 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h2><p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00043-easy-exclude/README.zh-CN.md">Source</a></p>
<p><code>Exclude</code> 是   TypeScript 中的一个内置工具类型，可以排除掉某个联合类型中的某些联合成员，例如 <code>Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;c&quot; | &quot;d&quot;&gt;</code> 将得到新的联合类型 <code>&quot;a&quot; | &quot;b&quot;</code>。</p>
<p> 答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyExclude</span>&lt;T, K&gt; = T <span class="keyword">extends</span> K ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>这里利用到了 TypeScript 的 <code>extends</code> 关键字，并且利用到了其<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types">自动分配条件的特性</a>。简单来说，对于 <code>T extends U ? X : Y</code> 来说，当 <code>T</code> 为一个 <code>A | B</code> 的联合类型，那实际情况就变成 <code>(A extends U ? X : Y) | (B extends U ? X : Y)</code>。</p>
<p>且这一特性仅在左侧为泛型时才会触发，当使用 <code>&quot;a&quot; | &quot;b&quot; | &quot;c&quot; extends &quot;a&quot; ? &quot;e&quot; : &quot;f&quot;</code>  时得到的结果为 <code>&quot;f&quot;</code> 并非 <code>&quot;e&quot; | &quot;f&quot;</code>，因为 <code>&quot;a&quot; | &quot;b&quot; | &quot;c&quot;</code> 并不能分配给 <code>&quot;a&quot;</code>。如果在使用泛型时候不想触发自动分配条件的特性，可以使用 <code>[]</code> 将关键词左侧和右侧包裹起来，如 <code>[T] extends [K]</code>。</p>
<h2 id="实现对象属性只读"><a href="#实现对象属性只读" class="headerlink" title="实现对象属性只读"></a>实现对象属性只读</h2><p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00007-easy-readonly/README.zh-CN.md">Source</a></p>
<p>Readonly 是 TypeScript 中的一个内置工具类型，可以将对象类型的所有属性都设置为只读，这意味着构造类型的属性不能重新分配，如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">Readonly</span>&lt;<span class="title class_">Todo</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Delete inactive users&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">todo.<span class="property">title</span> = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// Cannot assign to &#x27;title&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>TypeScript 在定义类型时，可以使用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#readonly-and-const"><code>readonly</code> 修饰符</a> 将对象属性定义为只读属性，这里就可以通过重新声明对象类型的 key 类型来将其所有 key 都定义为只读类型。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00008-medium-readonly-2/README.zh-CN.md">相同类型题目：对象部分属性只读</a></p>
<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案一：</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyExclude</span>&lt;T, K&gt; = T <span class="keyword">extends</span> K ? <span class="built_in">never</span> : T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyReadonly</span>&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [k <span class="keyword">in</span> K]: T[k];</span><br><span class="line">&#125; &amp; &#123; [k <span class="keyword">in</span> <span class="title class_">MyExclude</span>&lt;keyof T, K&gt;]: T[k] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二：</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyReadonly2</span>&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = <span class="title class_">Omit</span>&lt;T, K&gt; &amp;</span><br><span class="line">  <span class="title class_">Readonly</span>&lt;<span class="title class_">Pick</span>&lt;T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00009-medium-deep-readonly/README.zh-CN.md">相同类型题目：对象属性只读（递归）</a></p>
<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DeepReadonly</span>&lt;T&gt; = keyof T <span class="keyword">extends</span> <span class="built_in">never</span></span><br><span class="line">  ? T</span><br><span class="line">  : &#123; <span class="keyword">readonly</span> [k <span class="keyword">in</span> keyof T]: <span class="title class_">DeepReadonly</span>&lt;T[k]&gt; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="元组转换为对象"><a href="#元组转换为对象" class="headerlink" title="元组转换为对象"></a>元组转换为对象</h2><p>将一个元组类型转换为对象类型，这个对象类型的键/值和元组中的元素对应。</p>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tuple = [<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model 3&#x27;</span>, <span class="string">&#x27;model X&#x27;</span>, <span class="string">&#x27;model Y&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result = <span class="title class_">TupleToObject</span>&lt;<span class="keyword">typeof</span> tuple&gt; <span class="comment">// expected &#123; &#x27;tesla&#x27;: &#x27;tesla&#x27;, &#x27;model 3&#x27;: &#x27;model 3&#x27;, &#x27;model X&#x27;: &#x27;model X&#x27;, &#x27;model Y&#x27;: &#x27;model Y&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TupleToObject</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> T[<span class="built_in">number</span>]]: K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>我们要求传入的泛型 <code>T</code> 必须是数组，因此要求继承为 <code>any[]</code>，同时在题目示例中，我们使用 <code>typeof tuple</code> 来获取元组的类型，这样获取到的是一个 readonly 属性的元组，因此 T 必须继承 <code>readonly any[]</code>。</p>
<p>当 <code>T</code> 为元组时，可以使用 <code>T[number]</code> 将元组转化为一个联合类型，如 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;][number]</code> 即为 <code>&quot;a&quot; | &quot;b&quot; | &quot;c&quot;</code>。<code>[K in T[number]]: K</code> 可以将元组转化为 <code>Key: Value</code> 对应的形式。</p>
<h2 id="第一个元素"><a href="#第一个元素" class="headerlink" title="第一个元素"></a>第一个元素</h2><p>实现一个<code>First&lt;T&gt;</code>泛型，它接受一个数组<code>T</code>并返回它的第一个元素的类型。</p>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> arr2 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> head1 = <span class="title class_">First</span>&lt;arr1&gt; <span class="comment">// 应推导出 &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">type</span> head2 = <span class="title class_">First</span>&lt;arr2&gt; <span class="comment">// 应推导出 3</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//answer1</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">First</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [] ? <span class="built_in">never</span> : T[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//answer2</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">First</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="string">&#x27;length&#x27;</span>] <span class="keyword">extends</span> <span class="number">0</span> ? <span class="built_in">never</span> : T[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//answer3</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">First</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer A, ...infer <span class="title class_">Rest</span>] ? A : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>这道题看似很简单，只需要 <code>T[0]</code> 就可以获取到元组的第一个成员并返回，但是需要考虑用例为一个空元组的情况，比如 <code>First&lt;[]&gt;</code> 需要返回 <code>never</code>，而 <code>T[0]</code> 将返回 <code>undefined</code>。因此我们需要特殊处理该情况。</p>
<p>在第一种解法中，<code>T extends []</code> 相当于显式判断了 <code>T</code> 是否是一个空元组，如果是的话则直接返回 <code>never</code>。</p>
<p>第二种解法则是使用元组的 <code>length</code> 属性来判断元组是否为空，如果为空则返回 <code>never</code>。</p>
<p>第三种解法利用了关键词 <code>infer</code>，<code>infer</code> 可以用作类型推断，具体介绍可以查看<a target="_blank" rel="noopener" href="https://jkchao.github.io/typescript-book-chinese/tips/infer.html#%E4%BB%8B%E7%BB%8D">这里</a>。<code>T extends [infer A, ...infer Rest]</code> 表示如果 <code>T</code> 如果可以赋给 <code>[infer A, ...infer Rest]</code> 那么元组的第一个成员为泛型 <code>A</code>，其余成员使用展开符赋给泛型 <code>Reset</code>，如 <code>T</code> 为 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>，则 <code>A</code> 为 <code>&quot;a&quot;</code>，<code>Reset</code> 为 <code>[&quot;b&quot;, &quot;c&quot;]</code>。如果 <code>extends</code> 条件成立则返回 <code>A</code>，也就是元组中第一个元素的类型，如果不成立则说明 <code>infer</code> 无法推断，也就是说元组类型 <code>T</code> 的长度不足，因此返回 <code>never</code>。</p>
<h2 id="获取元组长度"><a href="#获取元组长度" class="headerlink" title="获取元组长度"></a>获取元组长度</h2><p>创建一个<code>Length</code>泛型，这个泛型接受一个只读的元组，返回这个元组的长度。</p>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tesla = [<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model 3&#x27;</span>, <span class="string">&#x27;model X&#x27;</span>, <span class="string">&#x27;model Y&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="keyword">const</span> spaceX = [<span class="string">&#x27;FALCON 9&#x27;</span>, <span class="string">&#x27;FALCON HEAVY&#x27;</span>, <span class="string">&#x27;DRAGON&#x27;</span>, <span class="string">&#x27;STARSHIP&#x27;</span>, <span class="string">&#x27;HUMAN SPACEFLIGHT&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> teslaLength = <span class="title class_">Length</span>&lt;<span class="keyword">typeof</span> tesla&gt; <span class="comment">// expected 4</span></span><br><span class="line"><span class="keyword">type</span> spaceXLength = <span class="title class_">Length</span>&lt;<span class="keyword">typeof</span> spaceX&gt; <span class="comment">// expected 5</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// answer 1</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Length</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = T[<span class="string">&#x27;length&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// answer 2</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Length</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: infer L &#125;  ?  L : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>用例中使用 <code>typeof</code> 来获取一个 const 常量的类型，因此泛型 <code>T</code> 要继承 <code>readonly</code> 只读类型的数组，否则用例会报错。</p>
<p>在元组类型中，与 JavaScript 数组一样的，都存在一个 <code>length</code> 属性，表示元组的长度。解法一直接取 <code>length</code> 属性，而解法二则是使用了 <code>infer</code> 推断的方式返回了推断值。</p>
<h2 id="Awaited"><a href="#Awaited" class="headerlink" title="Awaited"></a>Awaited</h2><p>假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 <code>T</code> 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。</p>
<p>例如：<code>Promise&lt;ExampleType&gt;</code>，请你返回 ExampleType 类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleType</span> = <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">MyAwaited</span>&lt;<span class="title class_">ExampleType</span>&gt; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 TypeScript 4.5 中已经内置了 <code>Awaited</code> 方法类型。</p>
</blockquote>
<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyAwaited</span>&lt;T <span class="keyword">extends</span> <span class="title class_">PromiseLike</span>&lt;<span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> <span class="title class_">PromiseLike</span>&lt;infer U&gt;</span><br><span class="line">  ? U <span class="keyword">extends</span> <span class="title class_">PromiseLike</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">    ? <span class="title class_">MyAwaited</span>&lt;U&gt;</span><br><span class="line">    : U</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>已知的，泛型 <code>T</code> 必须继承 Promise 类，因此使用 <code>T extends Promise&lt;any&gt;</code> 限制泛型 <code>T</code> 的类型。然后使用 <code>infer</code> 推断 Promise 返回的具体类型，如果 <code>extends</code> 为真则返回推断值，否则表示无法推断则返回 <code>never</code>，因此我们可以将 <code>MyAwait</code> 编写为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyAwait</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer U&gt; ? U : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>但是这样只能推断一层 Promise，我们题目中要求的是可以推断多层 Promise 的最终返回值，例如用例 <code>type Z1 = Promise&lt;Promise&lt;Promise&lt;string | boolean&gt;&gt;&gt;</code>，<code>MyAwait&lt;Z1&gt;</code> 需要返回 <code>string | boolean</code>。因此我们需要使用递归判断推断值 <code>U</code> 是否仍是一个 Promise 对象，如果是的话则使用 <code>MyAwaited</code> 对其进行递归调用，因此我们继续完善答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyAwaited</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer U&gt;</span><br><span class="line">  ? U <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">    ? <span class="title class_">MyAwaited</span>&lt;U&gt;</span><br><span class="line">    : U</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>但是对于用例 <code>type T = &#123; then: (onfulfilled: (arg: number) =&gt; any) =&gt; any &#125;</code>，套用上面的 <code>MyAwait</code> 会报错，因为它不是一个标准的 Promise 对象，这时候就需要使用 <code>PromiseLike</code>。</p>
<p><code>PromiseLike</code> 是  TypeScript 内置的一个 Promise 的 DuckType（看起来像但不是）。这是因为在 ES6 的标准 Promise 对象出现前就已经有了 Promise 的相关概念，如 <a target="_blank" rel="noopener" href="https://wiki.commonjs.org/wiki/Promises/A">Promise/A</a>。因此 TypeScript 提供了一个 <code>PromiseLike</code> 类型方便开发者使用给遵循了 Promise 标准但并不是 ES6 中的标准 Promise 的对象使用，因此最终的答案为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyAwaited</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer U&gt;</span><br><span class="line">  ? U <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">    ? <span class="title class_">MyAwaited</span>&lt;U&gt;</span><br><span class="line">    : U</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><p>实现一个 <code>IF</code> 类型，它接收一个条件类型 <code>C</code> ，一个判断为真时的返回类型 <code>T</code> ，以及一个判断为假时的返回类型 <code>F</code>。 <code>C</code> 只能是 <code>true</code> 或者 <code>false</code>， <code>T</code> 和 <code>F</code> 可以是任意类型。</p>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="title class_">If</span>&lt;<span class="literal">true</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt;  <span class="comment">// expected to be &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">If</span>&lt;<span class="literal">false</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt; <span class="comment">// expected to be &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">If</span>&lt;C <span class="keyword">extends</span> <span class="built_in">boolean</span>, T, F&gt; = C <span class="keyword">extends</span> <span class="literal">true</span> ? T : F</span><br></pre></td></tr></table></figure>

<h2 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h2><p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00533-easy-concat/README.zh-CN.md">Source</a></p>
<p>在类型系统里实现 JavaScript 内置的 <code>Array.concat</code> 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。</p>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Concat</span>&lt;[<span class="number">1</span>], [<span class="number">2</span>]&gt; <span class="comment">// expected to be [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Concat</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[], U <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = [...T, ...U];</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>TypeScript 的类型声明中，<code>...</code> 展开运算符是可用的，因此只需要展开数组类型的泛型即可。但是要注意存在用例 <code>Expect&lt;Equal&lt;Concat&lt;typeof tuple, typeof tuple&gt;, [1, 1]&gt;&gt;</code>，因此要使用 <code>readonly</code>。</p>
<h2 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h2><p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00898-easy-includes/README.zh-CN.md">Source</a></p>
<p>在类型系统里实现 JavaScript 的 <code>Array.includes</code> 方法，这个类型接受两个参数，返回的类型要么是 <code>true</code> 要么是 <code>false</code>。</p>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> isPillarMen = <span class="title class_">Includes</span>&lt;[<span class="string">&#x27;Kars&#x27;</span>, <span class="string">&#x27;Esidisi&#x27;</span>, <span class="string">&#x27;Wamuu&#x27;</span>, <span class="string">&#x27;Santana&#x27;</span>], <span class="string">&#x27;Dio&#x27;</span>&gt; <span class="comment">// expected to be `false`</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">IsEqual</span>&lt;X, Y&gt; =</span><br><span class="line">    (&lt;T&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">    (&lt;T&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">unknown</span>[], U&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [infer <span class="title class_">First</span>, ...infer <span class="title class_">Rest</span>]</span><br><span class="line">    ? <span class="title class_">Equal</span>&lt;<span class="title class_">First</span>, U&gt; <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="literal">true</span> : <span class="title class_">Includes</span>&lt;<span class="title class_">Rest</span>, U&gt;</span><br><span class="line">    : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>解析 ：</p>
<p>看到这个题目我们可能首先会考虑将 <code>Includes</code> 的第一个参数位传入的元组转为联合类型，然后如果第二个参数的类型如果对于该联合类型的 <code>extends</code> 结果为真，则说明该类型包含于元组中，实现如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[], U&gt; = U <span class="keyword">extends</span> T[<span class="built_in">number</span>] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>但我们编写的这个方法只能通过 <code>Includes&lt;[&#39;Kars&#39;, &#39;Esidisi&#39;, &#39;Wamuu&#39;, &#39;Santana&#39;], &#39;Dio&#39;&gt;</code> 这样的简单用例，对于稍微复杂的情况，比如元组中存在 <code>boolean</code> 这样的类型，那么 <code>false</code> 和 <code>true</code> 对于其的 <code>extends</code> 结果都未真，那么判断将会失败。亦或者是元组中存在 interface 类型，如 <code>Includes&lt;[&#123; readonly a: &#39;A&#39; &#125;], &#123; a: &#39;A&#39; &#125;&gt;</code> 则也无法正确判断（结果是 <code>true</code>，而预期值是 <code>false</code>）。</p>
<p>那么我们换一种思路，在不使用值对比的方式时，如果使用 JavaScript 编写数组的 includes 方法，我们可以构造一个 Map 的数据结构，将数组中所有的元素都作为 Map 的 key 值，然后查看目标值是否在 Map 上存在，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myIncludes</span>(<span class="params">arr, target</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    map[arr[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map[target] !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 TypeScript 的类型声明来实现这个方法，可以写为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[], U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> T[<span class="built_in">number</span>]]: <span class="literal">true</span></span><br><span class="line">&#125;[U] <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>当然，在 JavaScript 中以这种方式实现的 includes 方法不不能判断引用类型的值，我们在将引用类型的值作为对象的 Key 时，会被字符串化，如 <code>&#123;a: 123&#125;</code> 会被字符串化为 <code>&#123;[object Object]: true&#125;</code>。</p>
<p>相同的，在类型声明中，上面我们实现的 Includes 工具类型只能处理 <code>1</code>、<code>2</code> 、<code>&#39;a&#39;</code> 这种基本类型，遇到函数类型、interface、boolean 这样的类型则会直接跳过，不会作为 key 值写入到生成的 interface 中。面对 <code>Includes&lt;[&#123; a: &#39;A&#39; &#125;], &#123; a: &#39;A&#39; &#125;&gt;</code>、<code>Includes&lt;[false, 2, 3, 5, 6, 7], false&gt;</code> 这样的用例时无法正常处理，获取到的都是 <code>false</code>，而对于 <code>Includes&lt;[1 | 2], 1&gt;</code> 这样包含了这种由基础类型构成的联合类型的用例，内部会转化为 <code>&#123;1: true, 2: true&#125;</code>，因此结果会变为 <code>true</code>。</p>
<p>上面两种方式都没法满足我们的目标，我们继续思考，如果可以解决<strong>如何在 TypeScript 中准确判断两个类型是否相同</strong>、<strong>并且在类型声明中可以进行遍历操作</strong>，这样只要遍历元组中的每个元素是否与目标元素相同，就可以得出目标元素是否包含在元组中的结果了。</p>
<p>关于解决判断类型是否相同，我们编写一个 <code>IsEqual</code> 工具类，其来源可以查看<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650">这里</a>，通过该工具类可以查看类型是否相同，实现如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">IsEqual</span>&lt;X, Y&gt; =</span><br><span class="line">    (&lt;T&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">    (&lt;T&gt;<span class="function">() =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>对于遍历操作，TypeScript 中虽然不能使用 for 循环，但是可以使用 <code>extends</code> 进行条件判断，并且可以调用自身的类型声明，因此我们可以使用递归的方式实现遍历：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;<span class="title class_">Value</span> <span class="keyword">extends</span> <span class="built_in">any</span>[], <span class="title class_">Item</span>&gt; =</span><br><span class="line">	<span class="title class_">IsEqual</span>&lt;<span class="title class_">Value</span>[<span class="number">0</span>], <span class="title class_">Item</span>&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">		? <span class="literal">true</span></span><br><span class="line">		: <span class="title class_">Value</span> <span class="keyword">extends</span> [<span class="title class_">Value</span>[<span class="number">0</span>], ...infer <span class="title class_">Rest</span>]</span><br><span class="line">			? <span class="title class_">Includes</span>&lt;<span class="title class_">Rest</span>, <span class="title class_">Item</span>&gt;</span><br><span class="line">			: <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>我们已经接近标准答案了，但是上面的实现无法处理 <code>Includes&lt;[null], undefined&gt;</code> 这个用例，解决这个也并不复杂，我们只需要在递归前进行一个非空检查，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;<span class="title class_">Value</span> <span class="keyword">extends</span> <span class="built_in">any</span>[], <span class="title class_">Item</span>&gt; =</span><br><span class="line">  <span class="title class_">Value</span> <span class="keyword">extends</span> [<span class="title class_">Value</span>[<span class="number">0</span>], ...infer <span class="title class_">Rest</span>]</span><br><span class="line">    ? <span class="title class_">IsEqual</span>&lt;<span class="title class_">Value</span>[<span class="number">0</span>], <span class="title class_">Item</span>&gt; <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="literal">true</span> : <span class="title class_">Includes</span>&lt;<span class="title class_">Rest</span>, <span class="title class_">Item</span>&gt;</span><br><span class="line">    : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h2><p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/03057-easy-push/README.zh-CN.md">Source</a></p>
<p>在类型系统里实现通用的 <code>Array.push</code> 。</p>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Push</span>&lt;[<span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;3&#x27;</span>&gt; <span class="comment">// [1, 2, &#x27;3&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; = [...T, U]</span><br></pre></td></tr></table></figure>

<p>相同题目 <a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/03060-easy-unshift/README.zh-CN.md#unshift--">Shift</a> 不再记录。</p>
<h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/03312-easy-parameters/README.zh-CN.md">Source</a></p>
<p>TypeScript 内置工具类型 Parameters 可以提取函数的参数类型。</p>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">arg: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>&gt;; <span class="comment">// [arg: string]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arg</span> = <span class="variable constant_">T2</span>[<span class="number">0</span>] <span class="comment">// string</span></span><br></pre></td></tr></table></figure></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Typescript/">Typescript</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-62c7f2684e36ba34" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/02/a59d62597b50.html"><i class="fa fa-chevron-left">  </i><span>数据报告海报生成图片、PDF方案的技术调研</span></a></div><div class="next-post pull-right"><a href="/2024/01/9149c021f802.html"><span>手动实现 JavaScript 类的继承</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://blog.esunr.site/2024/02/467da063c417.html';
  this.page.identifier = '2024/02/467da063c417.html';
  this.page.title = 'TypeScript 类型体操通关记录';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'esunr-blog' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://esunr-blog.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://esunr-webapp.cdn.bcebos.com/blog/background.png?x-bce-process=image/quality,q_80/format,f_auto)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2025 By EsunR</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>